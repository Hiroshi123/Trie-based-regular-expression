

module Parser_.Sed_.Base where

import Control_.M
import Control_.State

import Parser_.Base_.Base
import Parser_.Base_.Bool
import Parser_.Base_.ByteStr
import Parser_.Base_.List
import Parser_.Base_.Int

import qualified Data.ByteString as BS
import qualified Data.ByteString.Char8 as BC


-- sed s two arguments /subjects which will be replaced if matched / strings which will be replaced

-- / address / function / address1 / address2 / option

-- if a given pattern is accepted on a address screenini

-- pattern space will be generated by default

data State_ = State_
  {
    --CONVFMT
    --convfmt :: [Char],
    set_ln    :: LineNumber,
    left_text :: Bs, 
    set_ps    :: PatternSpace,
    set_hs    :: HoldSpace,
    stdout    :: Bs,
    commands  :: [(Address,State State_ ())],
    options   :: Option
    
  } -- deriving (Show)

type LineNumber = Int

type Address =
  PatternSpace -> LineNumber -> Bool

any_ps _ _ = True

data Option =
  Option'
  {
    line_output    :: Bool,
    -- which is set by -n ,--quiet or --silent option
--    last_output    :: Bool,
    -- which is set by --quiet option
    commandFile    :: [Bs],
    -- which is set by -f option
    inputFileName  :: [Bs],
    -- which is provided by standard command line argument 
    outputFileName :: [Bs],
    -- which is set by -a option, note without -a option,
    -- sed w function will create files while it executes 1st line
    kindReg        :: RegKind
    -- which is set by -E or -r
  }

st1 =
  State_
  {
    set_ln = 0,
    left_text = "abcde\nvfavfa\nvfa",
    set_ps    = "",
    set_hs    = "",
    stdout    = "",
    commands  = [(any_ps,store_ps "")],
    options   =
    Option'
    {
      line_output    = True,
      commandFile    = [],
      inputFileName  = [],
      outputFileName = [],
      kindReg        = BRE
    }
  }

type Arg = Bs

map_0_arg :: [(Bs,Function)]
map_0_arg =
  [
    ("l",L' ),
    ("p",P' ),
    ("P",P''),
    ("q",Q' ),
    ("d",D' ),
    ("D",D''),
    ("g",G' ),
    ("G",G''),
    ("h",H' ),
    ("H",H''),
    ("x",X' ),
    (" ",Space'),
    ("#",Sharp'),
    ("=",Eq')
  ]

map_1_arg :: [([Char], Arg -> Function)]
map_1_arg =
  [
    ("a",A' ),
    ("i",I' ),
    ("n",N' ),
    ("N",N''),
    ("r",R' ),
    ("w",W' ),
    ("b",B' ),
    ("t",T' ),
    (":",Colon')
  ]
  
data Function =
  -- substitution
  S' Arg Arg | Y' Arg Arg |
  -- append before , insert after
  A' Arg | I' Arg | L' |
  -- print to stdout
  N' Arg | N'' Arg | P' | P'' |
  -- quit
  Q' |
  -- delete pattern space
  C' Arg | D' | D'' |
  -- copy to pattern space ,
  -- copy to hold space ,
  -- swap
  G' | G'' | H' | H'' | X' |
  -- read file , write file
  R' Arg | W' Arg |
  -- with label to represent reapeat
  B' Arg | T' Arg |
  -- colon -> label
  -- space -> jump empty line (^$)
  -- sharp -> comment out
  -- eq    -> line number
  Colon' Arg | Space' | Sharp' | Eq'
  
  deriving (Show)


data RegKind =
  ERE | BRE | SRE
  deriving (Show)
  
type Bs = BS.ByteString
type PatternSpace = Bs
type HoldSpace = Bs

swap_ps_hs :: PatternSpace -> State State_ ()
swap_ps_hs x =
  get >==
  (\st@(State_ {set_ln = ln , set_ps = ps , set_hs = hs , .. } ) ->
     put (State_ {set_ln = ln , set_ps = hs , set_hs = ps , .. } ) >== (\x2 -> r' x2)
  )
  
copy_to_hs :: PatternSpace -> State State_ ()
copy_to_hs x =
  get >==
  (\st@(State_ {set_ln = ln , set_ps = ps , set_hs = hs , .. } ) ->
     put (State_ {set_ln = ln , set_ps = ps , set_hs = ps , .. } ) >== (\x2 -> r' x2)
  )
  
copy_to_ps :: PatternSpace -> State State_ ()
copy_to_ps x =
  get >==
  (\st@(State_ {set_ln = ln , set_ps = ps , set_hs = hs , .. } ) ->
     put (State_ {set_ln = ln , set_ps = hs , set_hs = hs , .. }) >== (\x2 -> r' x2)
  )

out_to_stdout x =
  get >==
  (\st@(State_ {stdout = out , .. } ) ->
     put (State_ {stdout = out , .. }) >== (\x2 -> r' x2)
  )
  
-- delete pattern space

rec_1_arg :: Parser Function
rec_1_arg =
  rec_1_arg_ ("a",A' )<|>
  rec_1_arg_ ("i",I' )<|>
  rec_1_arg_ ("n",N' )<|>
  rec_1_arg_ ("N",N'')<|>
  rec_1_arg_ ("r",R' )<|>
  rec_1_arg_ ("w",W' )<|>
  rec_1_arg_ ("b",B' )<|>
  rec_1_arg_ ("t",T' )<|>
  rec_1_arg_ (":",Colon')
  
rec_1_arg_ (x1,x2) =
  char x1 >==
  (\_ -> many item >==
    (\arg -> (r' (x2 arg)) )
  )
  
rec_0_arg :: Parser Function
rec_0_arg =
  
  rec_0_arg_ ("l",L' ) <|>
  rec_0_arg_ ("p",P' )<|>
  rec_0_arg_ ("P",P'')<|>
  rec_0_arg_ ("q",Q' )<|>
  rec_0_arg_ ("d",D' )<|>
  rec_0_arg_ ("D",D'')<|>
  rec_0_arg_ ("g",G' )<|>
  rec_0_arg_ ("G",G'')<|>
  rec_0_arg_ ("h",H' )<|>
  rec_0_arg_ ("H",H'')<|>
  rec_0_arg_ ("x",X' )<|>
  rec_0_arg_ (" ",Space')<|>
  rec_0_arg_ ("#",Sharp')<|>
  rec_0_arg_ ("=",Eq')
  
  
rec_0_arg_ (x1,x2) =
  (char x1) >== (\_ -> r' x2)
  
  
c_ x = store_ps x
c' = char "c" **> until' "/"

d_ :: State State_ ()
d_   = store_ps ""

-- move , swap operator
g_   = copy_to_ps
h_   = copy_to_hs
x_   = swap_ps_hs

-- print 
n_ = copy_to_ps
p_ = copy_to_ps

-- append, insert
a_ = copy_to_ps
i_ = copy_to_ps

-- substitution
s_ x1 x2 = x1
y_ x1 x2 = x1

s' = char "s" **>
  set_delimiter >==
  (\d ->
     until' d >==
     (\x1 -> char d **>
       until' d >==
       (\x2 -> char d **> s'_flags >==
         (\fl -> r' (string x1,x2,fl))
       )
     )
  )
  
  
s'_flags =
  (char "g" >== (\_ -> r' 0) ) <|>
  num -- <|>
  -- char "p" >== (\_ -> )
  
set_delimiter = item 
--  item >== (\x -> r' x)
  
store_ps :: PatternSpace -> State State_ ()
store_ps x =
  get >==
  (\st@(State_ {set_ps = ps , .. } ) ->
     put (State_ { set_ps = x , .. } ) >== (\x2 -> r' x2)
  )
  
load_ln :: State State_ Int
load_ln = get >== (\x -> r' (set_ln x))

load_ps :: State State_ PatternSpace
load_ps = get >== (\x -> r' (set_ps x))

inc_ln :: State State_ ()
inc_ln = 
  get >==
  (\st@(State_ {set_ln = ln , .. } ) ->
     put (State_ {set_ln = ln+1 , .. }) >== (\x2 -> r' x2)
  )

-- 1. inc_ln
-- 2. store_ps
-- 3. load_ln,load ps -> address confirmation
-- if address is matched, apply functions which has been set
-- 4. update states by applying functions

-- State 
-- State

address_ :: Parser (Int, Int)
address_ =
  num2_ <|> num1_ <|> last_
  
num2_ =
  num >==
  (\x1 -> 
      (char ",") **>
      num >== (\x2 -> r' (x1,x2) )
  )
  
num1_ = num >== (\x -> r' (x,x))

last_ = char "$" >== (\x -> r' (3,3))

context_ = num1_ 

  
